/*----------------------------------------------------------------------
 * Copyright (C) 2016, 2017 Pedro Falcato
 *
 * This file is part of Spartix, and is made available under
 * the terms of the GNU General Public License version 2.
 *
 * You can redistribute it and/or modify it under the terms of the GNU
 * General Public License version 2 as published by the Free Software
 * Foundation.
 *----------------------------------------------------------------------*/
/**************************************************************************
 *
 *
 * File: pmm.c
 *
 * Description: Contains the implementation of the kernel's PMM
 *
 * Date: 4/3/2016
 *
 *
 **************************************************************************/
#include <kernel/pmm.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
/* size of physical memory */
static size_t pmm_memory_size = 0;
static uint32_t pushed_blocks = 0;
/* Kernel addresses reserved for pmm stack */
static uintptr_t *pmm_stack_space = NULL;
extern uint32_t end;
static uint32_t last_entry = 0;
static size_t _used_mem = 0;
static _Bool is_initialized = false;
stack_t *stack = NULL;
size_t pmm_get_used_mem()
{
	return _used_mem;
}

void pmm_push(uintptr_t base, size_t size, size_t kernel_space_size)
{
	if(base == 0)
	{
		base += 0x1000;
		size -= 0x1000;
	}
	/* Don't alloc the kernel */
	if (base == 0x100000) {
		base += kernel_space_size;
	}
	for (unsigned int i = 0; i < pushed_blocks + 1; i++)
		if (stack->next[i].base == 0 && stack->next[i].size == 0) {
			stack->next[i].base = base;
			stack->next[i].size = size;
			stack->next[i].magic = 0xFDFDFDFD;
			last_entry = i;
			break;
		}
	pushed_blocks++;
}

void pmm_pop()
{
	if (last_entry == 0)
		return;

	stack->next[last_entry].base = 0;
	stack->next[last_entry].size = 0;
	stack->next[last_entry].magic = 0xCDCDCDCD;
}

void pmm_init(size_t memory_size, uintptr_t stack_space)
{
	if (is_initialized)
		return;
	pmm_memory_size = memory_size * 1024;
	pmm_stack_space = (uintptr_t *) stack_space;
	stack = (stack_t *) stack_space;
	memset(stack, 0, 4096);
	stack->next = (stack_entry_t *) (stack_space + sizeof(stack_t));
	is_initialized = true;
}
int pmm_dbg = 0;
void pmm_opt(int i)
{
	pmm_dbg = 1;
}
void pmm_print_tabl()
{
	for(unsigned int i = 0; i < pushed_blocks; i++)
	{
		printf("Base address: %p\n Size: %x\n", stack->next[i].base, stack->next[i].size);
	}
}
void *bootmem_alloc(size_t blocks)
{
	if (!is_initialized)
		return (void *) 0xDEADDEADDEAD;
	uintptr_t ret_addr = 0;
	for (unsigned int i = pushed_blocks-1; i; i--)
		if (stack->next[i].base != 0 && stack->next[i].size != 0 && stack->next[i].size >= PMM_BLOCK_SIZE * blocks)
		{
			if (stack->next[i].size >= blocks * PMM_BLOCK_SIZE)
			{
				ret_addr = stack->next[i].base;
				stack->next[i].base += PMM_BLOCK_SIZE * blocks;
				stack->next[i].size -= PMM_BLOCK_SIZE * blocks;
				_used_mem += PMM_BLOCK_SIZE * blocks;
				return (void *) ret_addr;
			}
		}

	return NULL;
}

void pfree(size_t blocks, void *p)
{
	if (!blocks)
		return;
	if (!p)
		return;
	memmove((void *) &stack->next[1], (void *) &stack->next[0],
		sizeof(stack_entry_t) * pushed_blocks);
	_used_mem -= PMM_BLOCK_SIZE * blocks;
	stack->next[0].base = (uintptr_t) p;
	stack->next[0].size = PMM_BLOCK_SIZE * blocks;
	stack->next[0].magic = 0xFDFDFDFD;
	pushed_blocks++;
}
typedef struct
{
        char *start_address;
        char *end_address;
        size_t size; // Just for convinience
        struct buddy_block *top;
} memory_zone_t;

memory_zone_t dma = {0};
memory_zone_t high_mem = {0};
void pmm_init_new(size_t memory_size)
{
	if (is_initialized)
		return;
	pmm_memory_size = memory_size * 1024;
	
}
